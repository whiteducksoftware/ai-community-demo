"""Tools to search through local memory store."""

import json
from typing import Any
import requests

from flock.core import flock_tool
from flock.core.logging.logging import get_logger

MEMORY_BASE_URL = "http://localhost:9001/"

LOGGER = get_logger("tools.kernel_memory")


@flock_tool
async def check_knowledge_base_health() -> str:
    """Check if the Memory store is healthy and available for search.
    Takes no arguments.

    Returns:
        status: str -> If healthy: "healthy", otherwise: "unhealthy"
    """

    health_endpoint = "health"

    try:
        # send the request
        result = requests.get(url=f"{MEMORY_BASE_URL}{health_endpoint}")
        
        if result.status_code == 200:
            return "healthy"
        
        else:
            LOGGER.error(
                f"Tool: 'check_if_memory_available': unhealthy: {result.status_code}"
            )
            return "unhealthy"

    except Exception as e:
        LOGGER.error(f"Tool: 'check_if_memory_available': {e}")
        return "unhealthy"


@flock_tool
async def get_indexes() -> list[str]:
    """Get the list of containers (aka 'indexes')  from the knowledge base.
    
    Each index has a unique name.
    Indexes are collections of memories extracted from the documents uploaded.
    
    Returns:
        A list of strings with the following schema.
        ["index_name", "another_index_name", "..."]
    """
    
    index_endpoint = "indexes"
    
    try:
        result = requests.get(
            url=f"{MEMORY_BASE_URL}{index_endpoint}"
        )
        
        if result.status_code == 200:
            body = result.content.decode()
            body_dict: dict[str, list[str]] = json.loads(body)
            indexes = body_dict.get("results", ["no indexes found"])
            parsed_indexes = []
            for index in indexes:
                parsed_indexes.append(index.get("name", ""))
            return parsed_indexes
        else:
            return []
    except Exception as e:
        LOGGER.error(f"Tool: 'get_indexes': Error: {e}")
        return []

def parse_query_result(result_body: dict[str, Any]) -> list[dict[str, Any]]:
    
    result_list: list[dict[str, Any]] = []
    
    # check if a "results"-key is present.
    results = result_body.get("results", [])
    
    for result in results:
        # format the result.
        index = result.get("index", "")
        source_name = result.get("sourceName", "")
        
        parsed_partitions: list[dict[str, Any]] = []
        # now for the partitions
        partitions = result.get("partitions", [])
        
        for partition in partitions:
            text = partition.get("text", "")
            relevance = partition.get("relevance", 0.0)
            parsed_partitions.append({
                "text": text,
                "relevance": relevance,
            })
        
        result_list.append({
            "source_name": source_name,
            "index": index,
            "partitions": parsed_partitions
        })
    
    return result_list

def parse_answer(answer_object: dict[str, Any]) -> dict[str, Any]:
    
    textual_answer = answer_object.get("text", "No answer provided")
    relevant_sources = []
    # now for the relevant sources.
    sources = answer_object.get("relevantSources", [])
    
    for source in sources:
        source_name = source.get("sourceName", "")
        index = source.get("index", "")
        parsed_partitions = []
        partitions = source.get("partitions", [])
        
        for partition in partitions:
            text = partition.get("text", "")
            relevance = partition.get("relevance", 0.0)
            
            parsed_partitions.append({
                "text": text,
                "relevance": relevance,
            })
        
        relevant_sources.append({
            "source_name": source_name,
            "index": index,
            "partitiions": partitions
        })
    
    return {
        "answer": textual_answer,
        "relevant_sources": relevant_sources,
    }

@flock_tool
async def ask_knowledge_base(
    index: str,
    question: str,
    min_relevance: float,
) -> dict[str, Any]:
    """Use the memories extracted from the uploaded files to generate an answer.
    The answer is generated by the integrated LLM of the knowledge-base.
    The answer contains citations which cite the uploaded files used to generate the answer.
    
    Args:
        index: str -> the name of the index to use for answer generation.
        question: str -> the question that needs answering.
        min_relevance: float -> a number between 0.1 and 1.0. Controls the relevance scoring for the files used to generate an answer. Relevance scoring is based on cosine similarity. Higher values mean more strict search, lower values mean more broad search. (a good default value is usually 0.6)
    
    Returns:
        answer: dict[str, Any] -> an object containing "answer": the answer to the question and "relevant_sources": files used as basis for generating an answer.
        OR error_message: str -> if arguments were provided incorrectly, the error_messages indicates what went wrong in the tool call.
    """
    
    ask_endpoint = "ask"
    
    url = f"{MEMORY_BASE_URL}{ask_endpoint}"
    
    # verify the parameters first
    if index == "" or index is None:
        return "index_name cannot be an empty string."
    if question == "" or question is None:
        return "question cannot be emtpy"
    if min_relevance < 0.1 or min_relevance > 1.0:
        return "min_relevance must be a positive value between 0.1 and 1.0"
    
    
    # now that we have verified the parameters, let's send the request.
    try:
        response = requests.post(
        url=url,
        json={
            "stream": False,
            "minRelevance": min_relevance,
            "question": question,
            "index": index,
        }
        )
        
        if response.status_code == 200:
            body = response.content.decode()
            body_dict = json.loads(body)
            answer = parse_answer(body_dict)
            return answer
        else:
            return f"Parameters were passed correctly, but the knowledge-base could not provide an answer. status-code: {response.status_code}"
        
    except Exception as e:
        LOGGER.error(
            f"Tool: 'ask_knowledge_base': Error: {e}"
        )
        return f"Parameters were passed correctly but knowledge-base responded with an Error: {e}"

@flock_tool
async def search_knowledge_base(
    index: str,
    query: str,
    minimum_relevance: float,
    limit: int,
) -> list[dict[str, Any]] | str:
    """Search the knowledge base for relevant snippets of text.
    
    Args:
        index: str -> The name of the index to search through.
        query: str -> A query in natural language that is used to perform semantic search.
        minimum_relevance: float -> an number between 0.1 and 1.0. Relevance ranking is based on cosine similarity of stored embeddings. Higher values result in a more strict search.
        limit: int -> How many results to return at most. For example: if limit is set to 5, only the top 5 results will be returned.
    
    Returns:
        results: list[dict[str, Any]] -> Results of the query if the correct arguments were provided.
        OR error_message: str -> if arguments were provided incorrectly, the error_message indicates what went wrong in the tool call.
    """
    
    search_endpoint = "search"
    
    url = f"{MEMORY_BASE_URL}{search_endpoint}"
    
    # verify parameters
    if index == "" or index is None:
        return "a valid index name must be provided"
    if query == "" or query is None:
        return "query cannot be empty"
    if minimum_relevance < 0.1 or minimum_relevance > 1.0:
        return "minimum_relevance must be a positive value between 0.1 and 1.0"
    if limit <= 0:
        return "limit cannot be negative and must be greater than 0"
    
    # now that verification is done, send the request
    try:
        response = requests.post(
            url=url,
            json={
                "index": index,
                "query": query,
                "minRelevance": minimum_relevance,
                "limit": limit,
            }
        )
        
        if response.status_code == 200:
            body = response.content.decode()
            body_dict: dict[str, Any] = json.loads(body)
            search_results: list[dict[str, Any]] = parse_query_result(body_dict)
            return search_results
        else:
            return f"Provided parameters were correct but knowledge-base responded with status: {response.status_code}"
    except Exception as e:
        LOGGER.error(
            f"Tool: 'search_knowledge_base': Error: {e}"
        ) 
        return f"Provided parameters were correct but knowledge-base returned an Error: {e}"